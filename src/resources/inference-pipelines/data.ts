// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.

import { APIResource } from '../../resource';
import * as Core from '../../core';

export class Data extends APIResource {
  /**
   * Publish an inference data point to an inference pipeline.
   */
  stream(
    inferencePipelineId: string,
    body: DataStreamParams,
    options?: Core.RequestOptions,
  ): Core.APIPromise<DataStreamResponse> {
    return this._client.post(`/inference-pipelines/${inferencePipelineId}/data-stream`, { body, ...options });
  }
}

export interface DataStreamResponse {
  success: true;
}

export interface DataStreamParams {
  /**
   * Configuration for the data stream. Depends on your **Openlayer project task
   * type**.
   */
  config:
    | DataStreamParams.LlmData
    | DataStreamParams.TabularClassificationData
    | DataStreamParams.TabularRegressionData
    | DataStreamParams.TextClassificationData;

  /**
   * A list of inference data points with inputs and outputs
   */
  rows: Array<Record<string, unknown>>;
}

export namespace DataStreamParams {
  export interface LlmData {
    /**
     * Name of the column with the model outputs.
     */
    outputColumnName: string;

    /**
     * Name of the column with the context retrieved. Applies to RAG use cases.
     * Providing the context enables RAG-specific metrics.
     */
    contextColumnName?: string;

    /**
     * Name of the column with the cost associated with each row.
     */
    costColumnName?: string;

    /**
     * Name of the column with the ground truths.
     */
    groundTruthColumnName?: string;

    /**
     * Name of the column with the inference ids. This is useful if you want to update
     * rows at a later point in time. If not provided, a unique id is generated by
     * Openlayer.
     */
    inferenceIdColumnName?: string;

    /**
     * Array of input variable names. Each input variable should be a dataset column.
     */
    inputVariableNames?: Array<string>;

    /**
     * Name of the column with the latencies.
     */
    latencyColumnName?: string;

    /**
     * Object with metadata.
     */
    metadata?: unknown;

    /**
     * Name of the column with the total number of tokens.
     */
    numOfTokenColumnName?: string | null;

    /**
     * Prompt for the LLM.
     */
    prompt?: Array<LlmData.Prompt>;

    /**
     * Name of the column with the questions. Applies to RAG use cases. Providing the
     * question enables RAG-specific metrics.
     */
    questionColumnName?: string;

    /**
     * Name of the column with the timestamps. Timestamps must be in UNIX sec format.
     * If not provided, the upload timestamp is used.
     */
    timestampColumnName?: string;
  }

  export namespace LlmData {
    export interface Prompt {
      /**
       * Content of the prompt.
       */
      content?: string;

      /**
       * Role of the prompt.
       */
      role?: string;
    }
  }

  export interface TabularClassificationData {
    /**
     * List of class names indexed by label integer in the dataset. E.g. ["Retained",
     * "Exited"] when 0, 1 are in your label column.
     */
    classNames: Array<string>;

    /**
     * Array with the names of all categorical features in the dataset. E.g. ["Age",
     * "Geography"].
     */
    categoricalFeatureNames?: Array<string>;

    /**
     * Array with all input feature names.
     */
    featureNames?: Array<string>;

    /**
     * Name of the column with the inference ids. This is useful if you want to update
     * rows at a later point in time. If not provided, a unique id is generated by
     * Openlayer.
     */
    inferenceIdColumnName?: string;

    /**
     * Name of the column with the labels. The data in this column must be
     * **zero-indexed integers**, matching the list provided in `classNames`.
     */
    labelColumnName?: string;

    /**
     * Name of the column with the latencies.
     */
    latencyColumnName?: string;

    /**
     * Object with metadata.
     */
    metadata?: unknown;

    /**
     * Name of the column with the model's predictions as **zero-indexed integers**.
     */
    predictionsColumnName?: string;

    /**
     * Name of the column with the model's predictions as **lists of class
     * probabilities**.
     */
    predictionScoresColumnName?: string;

    /**
     * Name of the column with the timestamps. Timestamps must be in UNIX sec format.
     * If not provided, the upload timestamp is used.
     */
    timestampColumnName?: string;
  }

  export interface TabularRegressionData {
    /**
     * Array with the names of all categorical features in the dataset. E.g. ["Gender",
     * "Geography"].
     */
    categoricalFeatureNames?: Array<string>;

    /**
     * Array with all input feature names.
     */
    featureNames?: Array<string>;

    /**
     * Name of the column with the inference ids. This is useful if you want to update
     * rows at a later point in time. If not provided, a unique id is generated by
     * Openlayer.
     */
    inferenceIdColumnName?: string;

    /**
     * Name of the column with the latencies.
     */
    latencyColumnName?: string;

    /**
     * Object with metadata.
     */
    metadata?: unknown;

    /**
     * Name of the column with the model's predictions.
     */
    predictionsColumnName?: string;

    /**
     * Name of the column with the targets (ground truth values).
     */
    targetColumnName?: string;

    /**
     * Name of the column with the timestamps. Timestamps must be in UNIX sec format.
     * If not provided, the upload timestamp is used.
     */
    timestampColumnName?: string;
  }

  export interface TextClassificationData {
    /**
     * List of class names indexed by label integer in the dataset. E.g. ["Retained",
     * "Exited"] when 0, 1 are in your label column.
     */
    classNames: Array<string>;

    /**
     * Name of the column with the inference ids. This is useful if you want to update
     * rows at a later point in time. If not provided, a unique id is generated by
     * Openlayer.
     */
    inferenceIdColumnName?: string;

    /**
     * Name of the column with the labels. The data in this column must be
     * **zero-indexed integers**, matching the list provided in `classNames`.
     */
    labelColumnName?: string;

    /**
     * Name of the column with the latencies.
     */
    latencyColumnName?: string;

    /**
     * Object with metadata.
     */
    metadata?: unknown;

    /**
     * Name of the column with the model's predictions as **zero-indexed integers**.
     */
    predictionsColumnName?: string;

    /**
     * Name of the column with the model's predictions as **lists of class
     * probabilities**.
     */
    predictionScoresColumnName?: string;

    /**
     * Name of the column with the text data.
     */
    textColumnName?: string;

    /**
     * Name of the column with the timestamps. Timestamps must be in UNIX sec format.
     * If not provided, the upload timestamp is used.
     */
    timestampColumnName?: string;
  }
}

export declare namespace Data {
  export { type DataStreamResponse as DataStreamResponse, type DataStreamParams as DataStreamParams };
}
